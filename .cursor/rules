# Penetration Testing Tool - Cursor Rules

## Code Style & Standards
- Use Python 3.11+ for optimal async performance and modern features
- Follow Python PEP 8 strictly
- Use type hints for all functions and class methods
- Implement comprehensive error handling with specific exceptions
- Add detailed docstrings using Google-style format
- Use async/await patterns for all I/O operations
- Implement proper logging with structured formats

## Security Requirements
- Never hardcode credentials, API keys, or sensitive data
- Use environment variables for all configuration
- Implement input validation for all user inputs
- Add rate limiting to prevent aggressive scanning
- Include legal disclaimers and authorization checks
- Sanitize all outputs to prevent information disclosure

## Architecture Patterns
- Use dependency injection for testability
- Implement factory patterns for scan modules
- Use dataclasses/Pydantic models for data structures
- Create abstract base classes for extensibility
- Implement proper singleton patterns for shared resources

## Testing Requirements
- Generate unit tests for all public methods
- Create integration tests for MCP communications
- Add performance tests for scanning operations
- Include security tests for input validation
- Mock external dependencies appropriately

## Documentation Standards
- Generate comprehensive README files
- Create API documentation for MCP servers
- Add inline comments for complex algorithms
- Document security considerations explicitly
- Include usage examples and tutorials

## Dependencies & Libraries
- Target Python 3.11+ for best performance and modern async features
- Prefer async libraries: aiohttp, asyncio, aiofiles
- Use established security tools: python-nmap, dnspython
- Implement MCP with official Python SDK
- Use Pydantic for data validation
- Include rich/typer for CLI interfaces

## File Organization
- Separate concerns: core/, mcp/, ai/, database/, cli/
- Use __init__.py files properly
- Group related functionality in modules
- Keep configuration in dedicated files
- Organize tests to mirror source structure

## Performance Considerations
- Implement connection pooling for HTTP requests
- Use semaphores to limit concurrent operations
- Add caching for DNS lookups and API calls
- Optimize database queries with proper indexing
- Profile critical paths for bottlenecks

## Error Handling Patterns
- Create custom exception classes for specific errors
- Implement retry logic with exponential backoff
- Log errors with appropriate severity levels
- Provide meaningful error messages to users
- Handle network timeouts gracefully

## AI Integration Guidelines
- Structure prompts for consistent AI responses
- Validate AI-generated outputs before use
- Implement fallback mechanisms for AI failures
- Cache AI responses for similar queries
- Use structured outputs (JSON) from AI calls